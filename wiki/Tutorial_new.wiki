#This tutorial is being written right now. It is not complete yet!!

= Introduction =

I will assume that you have downloaded the package and everything is working well in your computer. I will also assume that you usually work on Python. 

Please, be aware that in order for sphviewer to work, your system must have matplotlib, numpy, multiprocessing and scipy installed. 


= Structure of sphviewer=

Attending suggestions from Pablo Benitez Llambay, I modified completely the structure of sphviewer since the previous release (v 0.45). Please, do not use that version because it is deprecated and it will be not longer maintained anymore. 

The current release (v0.88) is structured as a package. There are different modules stores in a main directory. I think in this way it will be easier to maintain and to develop different branches in case it is necessary. 

sphviewer is divided in 4 different classes, which are represented in the following diagram:

http://py-sphviewer.googlecode.com/svn/wiki/figures/sphviewer_scheme.png

  # *sphviewer.Particles:* is the main class which stores the particles information and computes some of their properties which will be used later for making the image. 
  # *sphviewer.Camera:* is the main class which defines the parameters of the camera. 
  # *sphviewer.Scene:* Scene is the class that defines the link between the particles and the camera. In other words, it computes the Scene as seen from the camera point of view. 
  # *sphviewer.Render:* Render is the class that makes the final render. It takes the Scene and take a photo, which can be used later for making a movie.  

With this structure in mind we are going to make an image of a set of particles.

= How to use SPHViewer=

In order to understand how sphviewer works, let's make a disk with a radial density profile. We are going to use 10000 particles. In the next example we are going to use numpy, matplotlib and (of course) sphviewer:  

{{{
import numpy as np
import matplotlib.pyplot as plt
import sphviewer
}}}

Let's make a disk with a radial density profile embedded in an uniform density medium:

{{{
n1   = 10000
n2   = n1/3
r   = np.random.rand(n1)
phi = 2*np.pi*np.random.rand(n1)
x1 = r*np.cos(phi)
y1 = r*np.sin(phi)
z1  = 0.1*np.random.rand(n1)

x2 = -2+4*np.random.rand(n2)
y2 = -2+4*np.random.rand(n2)
z2 = -2+4*np.random.rand(n2)

x = np.append(x1, x2)
y = np.append(y1, y2)
z = np.append(z1, z2)
}}}

We can check how the distribution looks like:

{{{
plt.plot(x,y,'k.')
plt.xlim(-1,1)
plt.ylim(-1,1)
}}}

http://py-sphviewer.googlecode.com/svn/wiki/figures/disk_particles.png

Before continue, we have to assume some mass for the particles. We will assume that all particles have the same mass:

{{{
mass = np.ones(n1+n2)
}}}


Our goal is to render the particles with sphviewer. We are going to go through the steps faster; after that we will explain in more detail different features and details from each class we use. 

Steps for making a plot in sphviewer are basically 3:

  * Define the *Particles* of the Scene:

{{{
Particles = sphviewer.Particles(x,y,z,mass)
}}}

  * Define the *Scene* itself:

{{{
Scene = sphviewer.Scene(Particles)
}}}

  * *Render* the Scene:

{{{
Render = sphviewer.Render(Scene)
}}}

And this is everything you need to know for making a nice image :).
If we want to look at the final image we can use the set_image method from Render:

{{{
img = Render.get_image()
plt.imshow(img, origin='lower')
}}}


http://py-sphviewer.googlecode.com/svn/wiki/figures/first_image.png

Mmmm, we have to say that it does not look very well. What's going on? sphviewer have different tools that can help us to understand why the image does not look like as we expect. Because I think you are expecting results faster, I will give the recipe for getting a nice image from our Scene and after that I will stop in the details:
Let's improve the render:

{{{
Scene = sphviewer.Scene(Particles)
Scene.update_camera(r='infinity')
Render = sphviewer.Render(Scene)
Render.set_logscale()
img = Render.get_image()
extent = Render.get_extent()
plt.imshow(img, origin='lower',vmax=0.3, extent=extent)
}}}

http://py-sphviewer.googlecode.com/svn/wiki/figures/second_image.png

Which in my opinion is a pretty nice image. 

Now we are going to pay attention to the different steps we made in order to fully understand the structure of sphviewer and to know what we can do with it.

= sphviewer.Particles = 

The first step was to define the Particles class. As you may noted, the *Particles* class stores the particles information that sphviewer needs in order to define the Scene. The parameters of this class are:

*_sphviewer.Particles(xpos, ypos, zpos, mass, hsml=None, nb=32, verbose=False)_*

where _xpos_,_ypos_,_zpos_ and _mass_ do not need explanation because we already saw what they actually are. Regarding _hsml_ and _nb_, they are optional parameters but they are needed in the internal structure of sphviewer. _hsml_ is an array that stores the smoothing lengths of the particles. Smoothing lengths are used in order to determine the contribution of each particle to the density field, which is projected along the line of sight for making the image. There are different techniques for defining this quantity but we define it as the distance to the closer _nb_ neighbor. It is to say, in case _nb_ is 32, the smoothing lengths for each particles will be the distance to its 32 closer neighbor. 
There are many situations where you know the smoothing lengths of your particles. In such a cases, all you have to do is to provide the array with the hsml. Nevertheless, in many situations we don't know it value. In fact, in the previous example we didn't know it and we left the _hsml_ as _None_. Particles class will compute the hsml by itself searching the distance to the closer _nb_ neighbor (which is 32 by default) as far as you left _hsml_ as None. 

*Be aware that the computation of the smoothing lengths for a huge amount of particles may be very expensive*


Particles object has its own methods for making life easier.

They can be divided into setting methods and getting methods. Setting methods are useful for setting some property we forgot at the time where we define the object or for changing the data stored in the object. They are:

  * set_pos()
  * set_mass()
  * set_hsml()
  * set_nb() 

On the other hand, the getting methods are useful for getting some information from the object, like the smoothing lengths in case we want to save them after. They are:

  * get_pos()
  * get_mass()
  * get_hsml()
  * get_nb() 

Finally, in many situations we will be interested in looking the particles stored in the object without getting them. It can be done easily by using the _plot_ method:

  * plot('plane', axis=None, *kwargs)

where 'plane' is a reference to the 'xy', 'xz' or 'yz' projection and axis allow us to define the axis where we are going to plot the particles. _Kwargs_ are _matplotlib.lines.Line2D_ properties and are useful for changing the appearance of the plot. 

= sphviewer.Scene =

The second object we defined in the previous example was the *Scene*. The parameters of *Scene* are the following:



*_sphviewer.Scene(Particles, Camera=None)_*

As the diagram of the structure of sphviewer shows, *Scene* object groups the *Particles* and the *Camera*. You may remember that we didn't define any *Camera* in in the previous example. In general, defining a *Camera* involves the knowledge of the point at which you want to look and the distance of the Camera to that point. Defining it at the first time may be annoying for most user, so *Scene* have their own methods for setting the parameters of the *Camera*. In case you don't want to use an autocamera you have to provide a *Camera* object after the *Particles*. We will explain the *Camera* object after.

*Scene* class has different methods. We will summarize each one in the following:

  * Scene.set_autocamera(mode='density'): This method allows to change the mode that the autocamera uses in order to find the center of the image. By default autocamera uses a density criteria. It computes the density of the *Particles* and uses the position of the particles where the maximum is reached. It works very well when you have *Particles* with a radial density profile such us a dark matter halo or a galaxy. In cases you have a set of Particles without a clear density profile increasing towards the center, there are others modes like 'minmax', 'mean' or 'median'. Of course, in many situation you will be not happy with the results of an autocamera. In such a cases, you have to define the parameters of the camera that need to be corrected. It can be done with the method:

 * Scene.update_camera(**kargs): When you think you are not happy with some parameter of the *Camera*, you can change it with this method. **kargs are parameters of the *_sphviewer.Camera_* class. We will explain them in more detail after.


As *Particles*, *Scene* has their own getting methods. They are:

  * Scene.get_extent: It returns the extent array needed for converting 
the coordinates of the image (given in pixel units) into physical coordinates. It is an array like the following one:[xmin,xmax,ymin,ymax]; it is to say, an array containing the extreme values of the scene. It is very useful when you use *_matplotlib.imshow_* for plotting the resulting image after render the *Scene*.

  * Scene.get_scene: After making the Scene, the coordinates of the *Particles* are projected according to the position of the *Camera*. This method return the x and y positions, the smoothing lengths and the index of the particles that are active in the *Scene*. In principle this is an internal function that sphviewer needs. In most cases you don't need this data. However, you may often wish to see the *Scene* before render it. For doing so you don't need to get the data from the Scene. *Scene* has its own *plotting* method.

  * Scene.plot(axis=None, **kargs): This methods is similar to the plotting method from *Particles*. It plots in the selected axis the projected positions of your set of Particles. Sometimes it is better to see the *Scene* after render it. It ensures that everything is going as we expect.
 

= sphviewer.Render = 

This class takes as the only argument a *Scene* object. It renders the *Scene* and produces the final image. As every class of sphviewer, it has their own getting methods:

  * get_image: For most users, it is the only relevant getting method. It returns the matrix of the image you want. This matrix can be plotted with matplotlib.pylab.imshow() or saved wit matplotlib.pylab.imsave().
  * get_min: This method returns the minimum value of the image. It is useful for defining the dynamical range of the image. 
  * get_max: This method returns the maximum value of the image. It is useful for defining the dynamical range of the image. 
  * get_extent: The same as the get_extent method from *Scene*
  * get_logscale: It returns True or False depending on the scale of the image.


and setting methods:

  * set_logscale(): This method applies a logarithm scale to the image. It is to say, if M is the matrix of the image, after using this method, the *get_image* methods will return the image M as log10(M+1).


There is a method for saving the image directly to different formats, like *png*, *pdf*, *ps*, etc. This method is:

  * save(outputfile, **kargs): save allows to save the image in any of the common image formats. It uses the pyplot.save method. 
outputfile is a string containing a path to a filename, of a Python file-like object. If *format* is *None* and *fname* is a string, the output format is deduced from the extension of the filename. 

Finally, because the choice of the right dynamic range for the image can be difficult sometimes, there is a method for plotting the histogram of the image. It can help us to decide which range from the image is better to show:

  * histogram(axis=None, **kargs): It computes and shows the histogram of the image in the selected axis. **kargs are keyboard arguments from matplotlib.pylab.histogram().




= sphviewer.Camera =

In most cases you don't need to define ant *Camera* class. I recommend you let the *Scene* take care of it. However, once *Scene* defines its own *Camera*, you will need to check its parameters and eventually to change some of them. The parameters of the Camera are basically the following ones:


|| *Parameter* || *Function* ||
||  x,y,z   || position at which the camera points out ||
||  r          || distance of camera from the (x,y,z) point. ||
||  t, p || spherical angles to define the position of the camera. ||
||  zoom || Zoom of the camera. zoom is 1 by default and defines a Field of View (FOV) = 90º. Note that the only way for changing the FOV by setting this parameter. ||
|| xsize,ysize    || Number of pixels of the resulting image. With this paremeter you can set the "MPx" of the camera. Note that the higher the resolution, the higher the processing time. ||

In case you want to create a *Camera* object from scratch you have to define every parameter. *You can not left any of them without definition*.

As every sphviewer class, Camera has getting and setting methods. Currently, the only getting methods is:

  *get_params(): This methods returns a dictionary containing the parameters of the *Camera*.

and there are two setting methods:

  *set_params(): This method allows to define an specific parameter of the *Camera*, such as the zoom, r, and so on.

  *set_autocamera(): This method allows to get all the parameters of the *Camera* automatically. The disadvantage is that it must be fed with a *Particle* object.   

Finally, there is a final feature that can help you in many situations. Many times we have the need to know the position of the *Camera* respect to our input set of *Particles*. This can be useful when we are want to make a movie showing a flyby and we need to plan the path of the Camera. In order to help the user to do that, *Camera* has its own plotting method. 

  *plot(plane='xy', axis=None, **kargs): This method allows the user to plot the camera as seen in the projection of the input data. Parameters are the same that sphviewer.Particles.plot().

In order to show how does it work, let's take the previous example and let's use the plot method:

{{{
fig = plt.figure(1,figsize=(15,5))
plane = ['xy','xz','yz']

for i in xrange(3):
    ax = fig.add_subplot(1,3,i)
    Particles.plot(plane[i], axis=ax, markersize=0.5)
    Scene.update_camera(r=1.5)
    Scene.Camera.plot(plane[i], axis=ax)
plt.show()
}}}


http://py-sphviewer.googlecode.com/svn/wiki/figures/camera.png


= Details =
Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages